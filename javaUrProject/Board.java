import greenfoot.*;  // (World, Actor, GreenfootImage, Greenfoot and MouseInfo)
/**
 * Board is the world class for the game. It will handle most of the interactions within the game. 
 * 
 * The image for Board was created by http://shaodom.deviantart.com  AND is being used in compliance with the creative commons license. The wallpaper image itself has not been modified. 
 * The image of the two kings was generated by microsoft copilot. More information in acknowledgements document. 
 * 
 * @author 
 * @version 12/11/2024
 */
public class Board extends World
{
    /* FIELDS */
    public static final int WORLD_WIDTH = 500;
    public static final int WORLD_HEIGHT = 800;
    
    private Space[] spaces;
    private Space[][] movementPathsIndex;
    
    // private final int NUM_PIECES = 3; //DO I actually need this? Maybe implement in later sprints. 
    private Piece[][] pieces;
    private int[][] pieceStartCoords; // includes coordinates for both players
    private Space[][] pieceMovementPath; // includes movement path for both players
    private int countForPlayerPieces; // a count used inside a for loop later in the program. 
                                      // Default value of 0 which is what we want
                                      
    private int state;
    public static final int WELCOME_SCREEN = 0;
    public static final int RULES_SCREEN = 1;
    public static final int SETUP = 2;
    public static final int PLAYER1_ROLL = 3;
    public static final int PLAYER1_MOVE = 4;
    public static final int PLAYER2_ROLL = 5;
    public static final int PLAYER2_MOVE = 6;
    public static final int PLAYER1_WIN = 7;
    public static final int PLAYER2_WIN = 8;
    public static final int INFO_SCREEN = 9;
    public static final int CHOOSE_GAMEMODE = 10;
    
    private int[] goalCountIndex;
    
    private boolean[] humanPlayerIndex; //variable to specify CPU or HUMAN 
    private boolean switchState;
    private boolean onStarSpace;
    private boolean[] playerRerollIndex;//boolean to store a value which will be used to determine if a player is rerolling and needs to have additional movement options
                                    
    private Die die;
    private int dieRoll;
    private int dieRollMapped;
    private static final int TEXT_Y_POS = 65;
    private static final int TEXT_READ_DELAY = 50;
    
    MouseInfo mouse = Greenfoot.getMouseInfo();
    private int mousex;
    private int mousey;
    private Piece tempPiece; // a temporary piece that will be used to show where a piece will move to
    
    private int stored_State; // var to store a state while on the info screen
    
    private String mode_message; // message for the current gamemode
    /**
     * Board constructor.
     * 
     */
    public Board()
    {    
        super(WORLD_WIDTH, WORLD_HEIGHT, 1, false);
        
        humanPlayerIndex = new boolean[] {true,false}; //player1, player2 `isHuman` index
        playerRerollIndex = new boolean[] {false,false};
        spaces = new Space[20];
        pieces = new Piece[2][3];
        
        pieceStartCoords = new int[][] {  {25,265}, {75,265}, {125,265},
                                          {25,350}, {75,350}, {125,350}  };
        goalCountIndex = new int[2];
        goalCountIndex[0] = 0;
        goalCountIndex[1] = 0;
        
        state = WELCOME_SCREEN;
        switchState = false;
        onStarSpace = false;
        this.setBackground("start_screen.jpg");
    }// end contstructor Board
    /**
     * Prepares the world.
     */
    private void prepare()
    {
        setBackground("Board.png");
        // place spaces on the board at correct positions
        for (int spaceNum = 0; spaceNum < 20; spaceNum++)
        {
            switch ( spaceNum ) 
            {
                case 0,1,2,3,5,6,7:
                    spaces[spaceNum] = new Space(false);
                    addObject(spaces[spaceNum], (int)(WORLD_WIDTH / 2), (78 * spaceNum + 150));
                    break;
                case 4:
                    spaces[spaceNum] = new Space(true);
                    addObject(spaces[spaceNum], (int)(WORLD_WIDTH / 2), (78 * spaceNum + 150));
                    break;
                case 8:
                    spaces[spaceNum] = new Space(false);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) - 78), spaces[spaceNum-8].getY());
                    break;
                case 9:
                    spaces[spaceNum] = new Space(true);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) - 78), spaces[spaceNum-8].getY());
                    break;
                case 10:
                    spaces[spaceNum] = new Space(false);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) + 78), spaces[spaceNum-10].getY());
                    break;
                case 11:
                    spaces[spaceNum] = new Space(true);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) + 78), spaces[spaceNum-10].getY());
                    break;
                case 12,13,14:
                    spaces[spaceNum] = new Space(false);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) - 78), spaces[spaceNum-8].getY());
                    break;
                case 15:
                    spaces[spaceNum] = new Space(true);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) - 78), spaces[spaceNum-8].getY());
                    break;
                case 16,17,18:
                    spaces[spaceNum] = new Space(false);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) + 78), spaces[spaceNum-12].getY());
                    break;
                case 19:
                    spaces[spaceNum] = new Space(true);
                    addObject(spaces[spaceNum], (int)((WORLD_WIDTH / 2) + 78), spaces[spaceNum-12].getY());
                    break;
                default:
                    break;
            }// end switch
        }// end for
        
        // Set up to map movement paths
        int[][] arrayMovementPathIndexPlayers = { {9,8,0,1,2,3,4,5,6,7,15,14,13,12}, {11,10,0,1,2,3,4,5,6,7,19,18,17,16} };
        movementPathsIndex = new Space[2][14];
        // Map movement paths
        for (int playerIndex = 0; playerIndex < 2; playerIndex++)
        {
            for (int movementPathIndex = 0; movementPathIndex < movementPathsIndex[0].length; movementPathIndex++ )
            {
                movementPathsIndex[playerIndex][movementPathIndex] = spaces[arrayMovementPathIndexPlayers[playerIndex][movementPathIndex]];
            }// end for
        }// end for
        
        // This for loop creates the new pieces and adds them to the screen in their respective positions based on
        // the 2-D index pieceStartCoords
        for ( int playerNum = 0; playerNum < 2; playerNum++ )
        {
            for ( int pieceNum = 0; pieceNum < 3; pieceNum++ )
            {
                pieces[playerNum][pieceNum] = new Piece(playerNum, pieceStartCoords[countForPlayerPieces][0],pieceStartCoords[countForPlayerPieces][1], false);
                addObject(pieces[playerNum][pieceNum], pieceStartCoords[countForPlayerPieces][0],pieceStartCoords[countForPlayerPieces][1]);
                countForPlayerPieces ++;
            }// end for
        }// end for
        
        // add die
        die = new Die();
        addObject( die, 400, 325);
        state = CHOOSE_GAMEMODE;
    }// end method prepare
    
    /** 
     * Act method for the Board.
     */
    public void act()
    {
        switch ( state ) {
            case WELCOME_SCREEN:
                if (Greenfoot.getKey() != null) // switch state / move on when the player presses any key
                {
                    state = RULES_SCREEN;
                } // end if
                break;
            case RULES_SCREEN:
                // 1. Set image to a rules screen (done in the method before)
                setBackground("rules_screen.jpg");
                // 2. Add a button that starts the game, also add a button that leads to a learn more page (tangential learning)
                if(Greenfoot.isKeyDown("space"))
                {
                    state = SETUP;
                } // end if
                // 3. Transition to the gameplay when it begins. 
                break;
            case SETUP:
                prepare();
                break;
            case CHOOSE_GAMEMODE:
                showText("Choose a gamemode. Press `enter` to continue. ", WORLD_WIDTH/2, TEXT_Y_POS - 25);
                showText("Press `b` for player vs player.", WORLD_WIDTH/2, TEXT_Y_POS - 5);
                showText("Press `n` for player vs cpu (default).", WORLD_WIDTH/2, TEXT_Y_POS + 15);
                showText("Press `m` for cpu vs cpu.", WORLD_WIDTH/2, TEXT_Y_POS + 35);
                checkGamemode();
                if(Greenfoot.isKeyDown("enter"))
                {
                    showText(null, WORLD_WIDTH/2, TEXT_Y_POS - 25);
                    showText(null, WORLD_WIDTH/2, TEXT_Y_POS - 5);
                    showText(null, WORLD_WIDTH/2, TEXT_Y_POS + 15);
                    showText(null, WORLD_WIDTH/2, TEXT_Y_POS + 35);
                    state = PLAYER1_ROLL;
                } // end if
                break;
            case PLAYER1_ROLL:
                rollDie(0);
                break;
            case PLAYER1_MOVE:
                updateMouse();
                determineMoveablePieces(0); 
                if ( !switchState ) {
                    doMovePlayer(0);
                    return; 
                } // end if
                updateGameState(0);  
                break; 
            case PLAYER2_ROLL:
                rollDie(1); 
                break;
            case PLAYER2_MOVE:
                updateMouse();
                determineMoveablePieces(1); 
                if ( !switchState ) {
                    doMovePlayer(1);
                    return;
                } // end if         
                updateGameState(1);  
                break;
            case PLAYER1_WIN:
                showText("Player 1 WINS!!", WORLD_WIDTH / 2, TEXT_Y_POS);
                Greenfoot.delay(70);
                showText("Press the `y` key to play again, Press `n` to quit.", WORLD_WIDTH / 2, TEXT_Y_POS);;
                Greenfoot.delay(70);
                playAgain();
                break;
            case PLAYER2_WIN:
                showText("Player 2 WINS!!", WORLD_WIDTH / 2, TEXT_Y_POS);
                Greenfoot.delay(70);
                showText("Press the `y` key to play again, Press `n` to quit.", WORLD_WIDTH / 2, TEXT_Y_POS);
                Greenfoot.delay(70);
                playAgain();
                break;
            case INFO_SCREEN:
                // 1. If a key is pressed, anytime during gameplay, switch to info screen (done)
                setBackground("info_Board.png");
                showInfoText();
                // 1_1. Make all objects invisible for duration of being on the info screen. Do this with opacity. Return them to previous state when leaving. 
                setObjectsInvisible();
                // 1_2 call choose gamemode method so that the user can change the mode while on the info screen
                checkGamemode();
                // 2. Allow seamless transition back to the game and it should still be at whatever point they were at. 
                if (Greenfoot.isKeyDown("space"))
                {
                    state = stored_State;
                    showText(null, WORLD_WIDTH/2, WORLD_HEIGHT/2);
                    removeInfoText();
                    setBackground("Board.png");
                    setObjectsVisible();
                }// end if
                break;
            default:
                break;
        } // end switch
        // When the i key is pressed, store the current state and enter the info screen. 
        if (Greenfoot.isKeyDown("i") && state != INFO_SCREEN && state != WELCOME_SCREEN && state != RULES_SCREEN && state != SETUP)
        {
            stored_State = state;
            state = INFO_SCREEN;
        }// end if
        //show the current state at the bottom of the screen (using a multi way if/elif/else)
        if (state != INFO_SCREEN && state != WELCOME_SCREEN && state != RULES_SCREEN && state != SETUP)
        {
            if (humanPlayerIndex[0] == false )
            {
                mode_message = "cpu vs. cpu";
            }// end if
            else if (humanPlayerIndex[1] == true)
            {
                mode_message = "player vs. player";
            }// end elif
            else
            {
                mode_message = "player vs. cpu (default)";
            }
            showText("Current mode : " + mode_message,WORLD_WIDTH/2,WORLD_HEIGHT - 50);
        }// end if
    }// end method act
        
    /**
     * Rolls the die for the given player.
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     */
    public void rollDie (int playerIndex)
    {
        if (humanPlayerIndex[playerIndex] && !Greenfoot.mouseClicked(die))
        {
            showText("Player " + (playerIndex + 1) + " click the die to roll", WORLD_WIDTH / 2, TEXT_Y_POS);
            return; 
        } // end if
        
        dieRoll = Greenfoot.getRandomNumber(6) + 1;
        switch(dieRoll)
        {
            case 1:
                dieRollMapped = 0;
                break;
            case 2,3:
                dieRollMapped = 1;
                break;
            case 4,5:
                dieRollMapped = 2;
                break;
            case 6:
                dieRollMapped = 3;
                break;
        }// end switch
        showText("Player "+ (playerIndex + 1) + " rolls a " + dieRollMapped, WORLD_WIDTH / 2, TEXT_Y_POS);
        showText(String.valueOf(dieRollMapped), die.getX(), die.getY());
        Greenfoot.delay(TEXT_READ_DELAY);
        if (dieRollMapped == 1)
        {
            showText("Select a piece to move " + dieRollMapped + " space.", WORLD_WIDTH / 2, TEXT_Y_POS);
        }// end if
        else
        {
            showText("Select a piece to move " + dieRollMapped + " spaces.", WORLD_WIDTH / 2, TEXT_Y_POS);
        } // end else
        if (dieRollMapped == 0)
        {
            showText("Turn Skipped!",WORLD_WIDTH / 2, TEXT_Y_POS);
            Greenfoot.delay(TEXT_READ_DELAY);
            state = (playerIndex == 0 ? PLAYER2_ROLL : PLAYER1_ROLL);
        }
        else
        {
            state = (playerIndex == 0 ? PLAYER1_MOVE : PLAYER2_MOVE);
        } //end if/else
    }// end method rollDie
    
    /**
     * Determines which pieces are moveable for a player
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     */
    public void determineMoveablePieces(int playerIndex)
    {
        int otherPlayer = 1 - playerIndex;
        if (playerRerollIndex[playerIndex])
        {
            for(int player = 0; player < 2; player++)
            {
                for (int pieceIndex = 0; pieceIndex < pieces[player].length; pieceIndex++)
                {
                    pieces[player][pieceIndex].setMoveable(false);
                    pieces[player][pieceIndex].getImage().setTransparency(150);
                    int currentLocIndex = pieces[player][pieceIndex].getLocIndex();
                    int targetLocIndex;
                    if (player == playerIndex)
                    {
                        targetLocIndex = currentLocIndex + dieRollMapped;
                    }// end if
                    else
                    {
                        targetLocIndex = currentLocIndex - dieRollMapped;
                    }// end if/else
                    if (currentLocIndex == 14)
                    {
                        break;
                    } // end if
                    // an if statement with three different complex conditions
                    // it checks whether a piece is moveable by checking three possible ways it could be moveable
                    // 1. The target location is the goal zone
                    // 2. The target location is on the board, not occupied by either player
                    // 3. The target location is on the board, occupied by an enemy, but not in a star space
                    // make this more readable?
                    if (     targetLocIndex == 14
                        || ((targetLocIndex >= 0 && targetLocIndex <= 14) && !movementPathsIndex[player][targetLocIndex].isOccupied(player) && !movementPathsIndex[player][targetLocIndex].isOccupied(1 - player))
                        || ((targetLocIndex >= 0 && targetLocIndex <= 14) && movementPathsIndex[player][targetLocIndex].isOccupied(1 - player) && !movementPathsIndex[player][targetLocIndex].isStarSpace())
                        || targetLocIndex == -1
                        )
                    {
                        pieces[player][pieceIndex].setMoveable(true);
                        pieces[player][pieceIndex].setTargetLocIndex(targetLocIndex);
                        pieces[player][pieceIndex].getImage().setTransparency(255);
                    }// end if
                }// end for
            }//end for
        }// end if
        else
        {
            for (int pieceIndex = 0; pieceIndex < pieces[playerIndex].length; pieceIndex++)
            {
                pieces[playerIndex][pieceIndex].setMoveable(false);
                int currentLocIndex = pieces[playerIndex][pieceIndex].getLocIndex();
                int targetLocIndex = currentLocIndex + dieRollMapped;
                
                // an if statement with three different complex conditions
                // it checks whether a piece is moveable by checking three possible ways it could be moveable
                // 1. The target location is the goal zone
                // 2. The target location is on the board, not occupied by either player
                // 3. The target location is on the board, occupied by an enemy, but not in a star space
                // make this more readable?
                if (     targetLocIndex == 14
                    || ((targetLocIndex >= 0 && targetLocIndex <= 14) && !movementPathsIndex[playerIndex][targetLocIndex].isOccupied(playerIndex) && !movementPathsIndex[playerIndex][targetLocIndex].isOccupied(otherPlayer))
                    || ((targetLocIndex >= 0 && targetLocIndex <= 14) && movementPathsIndex[playerIndex][targetLocIndex].isOccupied(otherPlayer) && !movementPathsIndex[playerIndex][targetLocIndex].isStarSpace())
                    )
                {
                    pieces[playerIndex][pieceIndex].setMoveable(true);
                    pieces[playerIndex][pieceIndex].setTargetLocIndex(targetLocIndex);
                }// end if
            }// end for
        }// end if/else
    }// end method determineMoveablePieces
    
    
    /**
     * Check which piece to move for the player
     * 
     * @parm playerIndex        index of the current player (int 0 or 1).
     */
    public void doMovePlayer(int playerIndex)
    {
        int countPiecesNotMoveable = 0; 
        if (dieRollMapped == 1)
        {
            showText("Select a piece to move " + dieRollMapped + " space.", WORLD_WIDTH / 2, TEXT_Y_POS);
        }// end if
        else
        {
            showText("Select a piece to move " + dieRollMapped + " spaces.", WORLD_WIDTH / 2, TEXT_Y_POS);
        } // end else
        // Long if/else statement that basically does the same thing but differently based on if the player is rerolling or not. 
        // if the player is rerolling the game needs to check if the opponents pieces can be moved backwards as well
        if (playerRerollIndex[playerIndex])
        {
            // check for moves
            for (int player = 0; player < 2; player++)
            {
                for ( int playerPieceIndex = 0; playerPieceIndex < 3; playerPieceIndex++ )
                {
                    Piece currentPiece = pieces[player][playerPieceIndex];
                    if ( !currentPiece.isMoveable() ) 
                    {
                        countPiecesNotMoveable++;   
                        if ( countPiecesNotMoveable == 6 )
                        {
                            showText( "No moves!", WORLD_WIDTH / 2, TEXT_Y_POS);
                            Greenfoot.delay(TEXT_READ_DELAY);
                            
                            switchState = true;
                            playerRerollIndex[playerIndex] = false;
                            return; 
                        } // end inner if
                    } // end outer if 
                }// end for
            }// end for
            for (int player = 0; player < 2; player++)
            {
                for ( int playerPieceIndex = 0; playerPieceIndex < 3; playerPieceIndex++ )
                {
                    Piece currentPlayerPieceToCheck = pieces[player][playerPieceIndex];
                    if ( currentPlayerPieceToCheck.isMoveable() )
                    {
                        if (mouse != null)
                        {
                            if (currentPlayerPieceToCheck.getLocIndex() == 14)
                            {
                                break;
                            } // end if
                            else if (currentPlayerPieceToCheck.getLocIndex() == -1)
                            {
                                // a large series of statements that checks whether the mouse is hovering over the piece
                                // if so, creates a temp piece and adds it on the screen at the target location, removing it after
                                // since the act method runs many times per second, the temp location is shown even though the piece gets removed over and over. 
                                if (((mousex >= currentPlayerPieceToCheck.getStartingXCoord() - 25 && mousex <= currentPlayerPieceToCheck.getStartingXCoord() + 25) && 
                                     (mousey >= currentPlayerPieceToCheck.getStartingYCoord() - 25 && mousey <= currentPlayerPieceToCheck.getStartingYCoord() + 25)) && 
                                     currentPlayerPieceToCheck.getPlayerNum() == playerIndex)
                                {
                                    if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                    {
                                        if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                        {
                                            tempPiece = new Piece(playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                        } 
                                        else { 
                                            tempPiece = new Piece(playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                        } // if/else    
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);
                                    }
                                    else
                                    {
                                        tempPiece = new Piece(playerIndex, movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);    
                                    }
                                } // end if  
                                else if (((mousex >= currentPlayerPieceToCheck.getStartingXCoord() - 25 && mousex <= currentPlayerPieceToCheck.getStartingXCoord() + 25) && 
                                     (mousey >= currentPlayerPieceToCheck.getStartingYCoord() - 25 && mousey <= currentPlayerPieceToCheck.getStartingYCoord() + 25)) && 
                                     !(currentPlayerPieceToCheck.getPlayerNum() == playerIndex))
                                {
                                    // if the mouse is hovering over the piece (not in the starting zone)
                                    if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                    {
                                        if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                        {
                                            tempPiece = new Piece(1 - playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                        } 
                                        else { 
                                            tempPiece = new Piece(1 - playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                        } // if/else 
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece); 
                                    }
                                    else
                                    {
                                        tempPiece = new Piece(1 - playerIndex, movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true); 
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);    
                                    }
                                }// end elif
                            }
                            else
                            {
                                if (((mousex >= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() - 25 && mousex <= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() + 25) && 
                                     (mousey >= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() - 25 && mousey <= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() + 25)) && 
                                     currentPlayerPieceToCheck.getPlayerNum() == playerIndex)
                                {
                                    if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                    {
                                        if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                        {
                                            tempPiece = new Piece(playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                        } 
                                        else { 
                                            tempPiece = new Piece(playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                        } // if/else 
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);
                                    }
                                    else
                                    {
                                        tempPiece = new Piece(playerIndex, movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);
                                    }
                                } // end if  
                                else if (((mousex >= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() - 25 && mousex <= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() + 25) && 
                                          (mousey >= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() - 25 && mousey <= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() + 25)) && 
                                          !(currentPlayerPieceToCheck.getPlayerNum() == playerIndex))
                                {
                                    if (currentPlayerPieceToCheck.getTargetLocIndex() == -1)
                                    {
                                            tempPiece = new Piece(1 - playerIndex, currentPlayerPieceToCheck.getStartingXCoord(), currentPlayerPieceToCheck.getStartingYCoord(), true);
                                            addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                            Greenfoot.delay(20);
                                            removeObject(tempPiece); 
                                    }
                                    else
                                    {
                                        if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                        {
                                            if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                            {
                                                tempPiece = new Piece(1 - playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                            } 
                                            else { 
                                                tempPiece = new Piece(1 - playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                            } // if/else 
                                            addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                            Greenfoot.delay(20);
                                            removeObject(tempPiece);
                                        }
                                        else
                                        {
                                            tempPiece = new Piece(1 - playerIndex, movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                            addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                            Greenfoot.delay(20);
                                            removeObject(tempPiece);  
                                        } 
                                    }
                                }// end elif
                            } 
                        } // end if
                        // player piece moves if clicked 
                        if ( humanPlayerIndex[playerIndex] && Greenfoot.mouseClicked(currentPlayerPieceToCheck) ) 
                        {                                                                          
                            handlePiece(playerIndex, currentPlayerPieceToCheck);
                            playerRerollIndex[playerIndex] = false;
                            switchState = true;  
                            return; 
                        } // end if 
                        // cpu moves with a 1/6 chance
                        if ( !humanPlayerIndex[playerIndex] && (Greenfoot.getRandomNumber(100) < 16) ) //a little less than a 1/6 chance
                        {
                            Greenfoot.delay(TEXT_READ_DELAY);
                            playerRerollIndex[playerIndex] = false;
                            handlePiece(player, currentPlayerPieceToCheck);
                            switchState = true; 
                            playerRerollIndex[playerIndex] = false;
                            return; 
                        } // end INNER if 
                    } // end OUTER if
                } // end for
            }// end for
        }// end if
        else
        {
            // check for moves
            for ( int playerPieceIndex = 0; playerPieceIndex < 3; playerPieceIndex++ )
            {
                Piece currentPiece = pieces[playerIndex][playerPieceIndex];
                if ( !currentPiece.isMoveable() ) 
                {
                    countPiecesNotMoveable++;   
                    if ( countPiecesNotMoveable == 3 )
                    {
                        showText( "No moves!", WORLD_WIDTH / 2, TEXT_Y_POS);
                        Greenfoot.delay(TEXT_READ_DELAY);
                        
                        switchState = true;
                        return; 
                    } // end inner if
                    
                } // end outer if 
            }// end for
            
            for ( int playerPieceIndex = 0; playerPieceIndex < 3; playerPieceIndex++ )
            {
                Piece currentPlayerPieceToCheck = pieces[playerIndex][playerPieceIndex];
                if ( currentPlayerPieceToCheck.isMoveable() )
                {
                    // if the mouse is on the screen
                    if (mouse != null)
                    {
                        if (currentPlayerPieceToCheck.getLocIndex() == 14)
                        {
                            break;
                        }
                        if (currentPlayerPieceToCheck.getLocIndex() == -1)
                        {
                            // a large series of statements that checks whether the mouse is hovering over the piece
                            // if so, creates a temp piece and adds it on the screen at the target location, removing it after
                            // since the act method runs many times per second, the temp location is shown even though the piece gets removed over and over. 
                            if (((mousex >= currentPlayerPieceToCheck.getStartingXCoord() - 25 && mousex <= currentPlayerPieceToCheck.getStartingXCoord() + 25) && 
                                     (mousey >= currentPlayerPieceToCheck.getStartingYCoord() - 25 && mousey <= currentPlayerPieceToCheck.getStartingYCoord() + 25)) && 
                                     currentPlayerPieceToCheck.getPlayerNum() == playerIndex)
                            {
                                if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                {
                                    if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                    {
                                        tempPiece = new Piece(playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                    } 
                                    else { 
                                        tempPiece = new Piece(playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                    } // if/else 
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                                else
                                {
                                    tempPiece = new Piece(playerIndex, movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);    
                                }
                            } // end if  
                            else if (((mousex >= currentPlayerPieceToCheck.getStartingXCoord() - 25 && mousex <= currentPlayerPieceToCheck.getStartingXCoord() + 25) && 
                                 (mousey >= currentPlayerPieceToCheck.getStartingYCoord() - 25 && mousey <= currentPlayerPieceToCheck.getStartingYCoord() + 25)) && 
                                 !(currentPlayerPieceToCheck.getPlayerNum() == playerIndex))
                            {
                                if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                {
                                    if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                    {
                                        tempPiece = new Piece(1 - playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                    } 
                                    else { 
                                        tempPiece = new Piece(1 - playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                    } // if/else 
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                                else
                                {
                                    tempPiece = new Piece(1 - playerIndex, movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true); 
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                            }// end elif  
                        }
                        else
                        {
                            if (((mousex >= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() - 25 && mousex <= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() + 25) && 
                                     (mousey >= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() - 25 && mousey <= movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() + 25)) && 
                                     currentPlayerPieceToCheck.getPlayerNum() == playerIndex)
                            {
                                if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                {
                                    if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                    {
                                        tempPiece = new Piece(playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                    } 
                                    else { 
                                        tempPiece = new Piece(playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                    } // if/else  
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                                else
                                {
                                    tempPiece = new Piece(playerIndex, movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                            } // end if  
                            else if (((mousex >= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() - 25 && mousex <= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getX() + 25) && 
                                      (mousey >= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() - 25 && mousey <= movementPathsIndex[1 - playerIndex][currentPlayerPieceToCheck.getLocIndex()].getY() + 25)) && 
                                      !(currentPlayerPieceToCheck.getPlayerNum() == playerIndex))
                            {
                                if (currentPlayerPieceToCheck.getTargetLocIndex() == -1)
                                {
                                    tempPiece = new Piece(1 - playerIndex, currentPlayerPieceToCheck.getStartingXCoord(), currentPlayerPieceToCheck.getStartingYCoord(), true);
                                    addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                    Greenfoot.delay(20);
                                    removeObject(tempPiece);
                                }
                                else
                                {
                                    if (currentPlayerPieceToCheck.getTargetLocIndex() == 14)
                                    {
                                        if ( currentPlayerPieceToCheck.getPlayerNum() == 0 )
                                        {
                                            tempPiece = new Piece(1 - playerIndex, 83 + goalCountIndex[0] * 50, 775, true);
                                        } 
                                        else { 
                                            tempPiece = new Piece(1 - playerIndex, 332 + goalCountIndex[1] * 50, 775, true);
                                        } // if/else 
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece); 
                                    }
                                    else
                                    {
                                        tempPiece = new Piece(1 - playerIndex, movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getX(), movementPathsIndex[1-playerIndex][currentPlayerPieceToCheck.getTargetLocIndex()].getY(), true);
                                        addObject(tempPiece, tempPiece.getStartingXCoord(), tempPiece.getStartingYCoord());
                                        Greenfoot.delay(20);
                                        removeObject(tempPiece);  
                                    }  
                                }    
                            }// end elif  
                        } 
                    } // end if 
                    // move piece if the player clicks it
                    if ( humanPlayerIndex[playerIndex] && Greenfoot.mouseClicked(currentPlayerPieceToCheck) ) 
                    {                                                                          
                        handlePiece(playerIndex, currentPlayerPieceToCheck);
                        
                        switchState = true;  
                        return; 
        
                    } // end if 
                    // cpu moves a piece with a 1/6 chance
                    if ( !humanPlayerIndex[playerIndex] && (Greenfoot.getRandomNumber(100) < 16) ) 
                    {
                        Greenfoot.delay(TEXT_READ_DELAY);
        
                        handlePiece( playerIndex, currentPlayerPieceToCheck );
                        
                        switchState = true; 
                        return; 
          
                    } // end INNER if 
                    
                } // end OUTER if
            } // end for
        }// end if/else
    }// end method doMovePlayer
    /**
     * Moves the piece for the player. 
     * 
     * @param playerIndex       index of the current player (int 0 or 1).             
     * @param selectedPlayerPiece       Piece to be handled. (Piece)   
     */
    public void handlePiece( int playerIndex, Piece selectedPlayerPiece )
    {
        if ( selectedPlayerPiece.getTargetLocIndex() >= 0 
              && 
             selectedPlayerPiece.getTargetLocIndex() < 14 ) 
        {
            movePieceTargetLoc(selectedPlayerPiece.getPlayerNum(), selectedPlayerPiece);
        }// end if 
        else if ( selectedPlayerPiece.getTargetLocIndex() == 14 ) 
        { 
            movePieceGoalZone(playerIndex, selectedPlayerPiece);
        } // end else if
        else if ( selectedPlayerPiece.getTargetLocIndex() == -1 ) //back to spawn
        {
            selectedPlayerPiece.setLocation(selectedPlayerPiece.getStartingXCoord(), selectedPlayerPiece.getStartingYCoord());
        }// end if/else
        if ( selectedPlayerPiece.getLocIndex() >= 0 && selectedPlayerPiece.getLocIndex() < 14) //the second condition should be redundant/impossible
        {
            movementPathsIndex[selectedPlayerPiece.getPlayerNum()][selectedPlayerPiece.getLocIndex()].setOccupiedIndex(selectedPlayerPiece.getPlayerNum(), false);
        } // end if
        selectedPlayerPiece.setLocIndex(selectedPlayerPiece.getTargetLocIndex());
    } // end method handlePiece
    
    /**
     * Move the piece to the target location
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     * @param selectedPlayerPiece       Piece to move to its target location
     */
    public void movePieceTargetLoc( int playerIndex, Piece selectedPlayerPiece )
    {
        int otherPlayer = 1 - playerIndex; 
        
        selectedPlayerPiece.setLocation( 
            movementPathsIndex[playerIndex][selectedPlayerPiece.getTargetLocIndex()].getX(), 
            movementPathsIndex[playerIndex][selectedPlayerPiece.getTargetLocIndex()].getY());
            
        movementPathsIndex[playerIndex][selectedPlayerPiece.getTargetLocIndex()].setOccupiedIndex(playerIndex, true);
        
        // if landed space is starspace the number of the player is the same as playerindex
        if ( (movementPathsIndex[selectedPlayerPiece.getPlayerNum()][selectedPlayerPiece.getTargetLocIndex()].isStarSpace()) && (selectedPlayerPiece.getPlayerNum() == playerIndex) )
        {
            onStarSpace = true;
        } // end if
        // if the target location is occupied
        if ( (movementPathsIndex[playerIndex][selectedPlayerPiece.getTargetLocIndex()].isOccupied(otherPlayer)) && (selectedPlayerPiece.getPlayerNum() == playerIndex)) 
        {
            if (selectedPlayerPiece.getLocIndex() == -1) // if the location is in the starting area, do not atttempt to reset current space, otherwise, do so
            {
                moveCapturedBackwards(playerIndex, selectedPlayerPiece);
            }// end if
            else
            {
                movementPathsIndex[playerIndex][selectedPlayerPiece.getLocIndex()].setOccupiedIndex(playerIndex, false); //set occupied in the current space to false so 
                                                                                                                  //the piece moving backwards can occupy this space if needed
                moveCapturedBackwards(playerIndex, selectedPlayerPiece);
            }
        } // end if
    } // end method movePieceTargetLoc
    /**
     * Moves a captured piece backwards and a replaces with the player's piece
     * 
     * @param playerIndex       index of the current player (int 0 or 1).          
     * @param selectedPlayerPiece       currently selected piece, piece in the target location of this piece will be moved back. (Piece)   
     */
    public void moveCapturedBackwards(int playerIndex, Piece selectedPlayerPiece)
    {
        int otherPlayer = 1 - playerIndex; 
        // iterate through all pieces, if the current location is the target location of the current player piece that is being moved,
        // iterate through spaces backwards from the current postion until we reach the nearest open space (or off of the board)
        for ( Piece currentOpponentPieceToCheck : pieces[otherPlayer] ) {
            if ( currentOpponentPieceToCheck.getLocIndex() == (selectedPlayerPiece.getTargetLocIndex())) 
            {
                int currentLocIndexForLoop = currentOpponentPieceToCheck.getLocIndex() - 1;
                //default solution if no other space is open (set to starting zone)
                currentOpponentPieceToCheck.setLocation(currentOpponentPieceToCheck.getStartingXCoord(), currentOpponentPieceToCheck.getStartingYCoord());
                currentOpponentPieceToCheck.setLocIndex(-1); 
                for (int indexCheckBackwards = currentLocIndexForLoop; indexCheckBackwards > -1; indexCheckBackwards--)
                {
                    if (!movementPathsIndex[otherPlayer][indexCheckBackwards].isOccupied(otherPlayer) && !movementPathsIndex[otherPlayer][indexCheckBackwards].isOccupied(playerIndex))
                    {
                        currentOpponentPieceToCheck.setLocation( 
                                        movementPathsIndex[otherPlayer][indexCheckBackwards].getX(), 
                                        movementPathsIndex[otherPlayer][indexCheckBackwards].getY());
                        currentOpponentPieceToCheck.setLocIndex(indexCheckBackwards);
                        movementPathsIndex[otherPlayer][indexCheckBackwards].setOccupiedIndex(otherPlayer, true);
                        break;
                    }// end if
                }// end for
                movementPathsIndex[playerIndex][selectedPlayerPiece.getTargetLocIndex()].setOccupiedIndex(otherPlayer, false);
            } // end if
        } // end for    
    } // end method moveCapturedBackwards
    /**
     * Move selected Piece into the goal zone for that player. 
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     * @param selectedPlayerPiece       currently selected piece to be moved to the goal zone. (Piece)
     */
    public void movePieceGoalZone( int playerIndex, Piece selectedPlayerPiece )
    {
        if ( playerIndex == 0 )
        {
            selectedPlayerPiece.setLocation(83 + goalCountIndex[0] * 50, 775);
        } 
        else { 
            selectedPlayerPiece.setLocation(332 + goalCountIndex[1] * 50, 775);
        } // if/else       
    } // end method movePieceGoalZone
    /**
     * Updates the game state when called. 
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     */
    public void updateGameState(int playerIndex)
    {
        switch ( playerIndex ) {
            case 0: 
                updateGoalCount(0);
            
                if ( goalCountIndex[0] == 3 ) {
                    state = PLAYER1_WIN; 
                } 
                else if (onStarSpace) {
                    showText("Player 1 landed on a \nstar space!", WORLD_WIDTH / 2, TEXT_Y_POS);
                    Greenfoot.delay(TEXT_READ_DELAY);
                    onStarSpace = false; 
                    playerRerollIndex[0] = true;
                    switchState = false; 
                    state = PLAYER1_ROLL;
        
                } 
                else { 
                    showText( "\nPlayer 2\nup next", WORLD_WIDTH / 2, TEXT_Y_POS );
                    
                    switchState = false; 
                    state = PLAYER2_ROLL; 
        
                } // end if/else
                break;
            
            case 1: 
                updateGoalCount(1);
                        
                if ( goalCountIndex[1] == 3 ) 
                {
                    state = PLAYER2_WIN; 
                } 
                else if (onStarSpace) {
                    showText("Player 2 landed on a \nstar space!", WORLD_WIDTH / 2, TEXT_Y_POS);
                    Greenfoot.delay(TEXT_READ_DELAY);
                    onStarSpace = false; 
                    playerRerollIndex[1] = true;
                    switchState = false; 
                    state = PLAYER2_ROLL; 
        
                } 
                else { 

                    showText( "\nPlayer 1\nup next", WORLD_WIDTH / 2, TEXT_Y_POS );
                    
                    switchState = false; 
                    state = PLAYER1_ROLL; 
        
                }
                break;
                
            default:
                break;
        } // end switch
    } // end method updateGameState
    /**
     * Updates the goal count for a given player. 
     * 
     * @param playerIndex       index of the current player (int 0 or 1).
     */
    public void updateGoalCount(int playerIndex)
    {
        goalCountIndex[playerIndex] = 0;    
        for ( Piece currentPlayerPieceToCheck : pieces[playerIndex] )
        {
            if ( currentPlayerPieceToCheck.getLocIndex() == 14 ) {
                goalCountIndex[playerIndex]++;
            } // end if
        } // end for loop
    } // end method updateGoalCount
    /**
     * Method that restarts the game so the user can play again.
     */
    public void playAgain()
    {
        switchState=false;
        if (Greenfoot.isKeyDown("y"))
        {
            // resets variables that need to be reset, changes properties of spaces and pieces
            playerRerollIndex[0] = false;
            playerRerollIndex[1] = false;
            
            state = SETUP;
            switchState = false;
            onStarSpace = false;
            for (int spaceIndex = 0;spaceIndex < 20;spaceIndex++)
            {
                spaces[spaceIndex].setOccupiedIndex(0, false);
                spaces[spaceIndex].setOccupiedIndex(1, false);
            }// end for
            for (int playerNum = 0;playerNum < 2;playerNum++){
                for (int pieceIndex = 0;pieceIndex<3 ;pieceIndex++)
                {
                    pieces[playerNum][pieceIndex].setLocation(pieces[playerNum][pieceIndex].getStartingXCoord(), pieces[playerNum][pieceIndex].getStartingYCoord());
                    pieces[playerNum][pieceIndex].setLocIndex(-1);
                    pieces[playerNum][pieceIndex].setTargetLocIndex(-1);
                }// end nested for
            }// end for
            updateGoalCount(0);
            updateGoalCount(1);
            state = PLAYER1_ROLL;
        }// end if
        else if (Greenfoot.isKeyDown("n"))
        {
            Greenfoot.stop();
        }// end if/else
    }// end method playAgain
    /**
     * Updates the position of the mouse in a few variables. 
     */
    public void updateMouse()
    {
        // save the postiion of the mouse for use within the tempPiece/piece target logic
        mouse = Greenfoot.getMouseInfo();
        if (mouse != null)
        {
            mousex = mouse.getX();
            mousey = mouse.getY();
        } // end if
    } // end method updateMouse
    /**
     * Sets all objects on the screen to invisible.
     */
    public void setObjectsInvisible()
    {
        for (int playerNum = 0; playerNum < 2; playerNum++)
        {
            for (Piece currentPiece : pieces[playerNum])
            {
                currentPiece.setInfoStatus(true);
                currentPiece.getImage().setTransparency(0);
            }// end for
        }// end for
        for (Space currentSpace : spaces)
        {
            currentSpace.getImage().setTransparency(0);
        }// end for
        die.getImage().setTransparency(0);
    } // end method setObjectsInvisible
    /**
     * Sets all objects on the screen to visible. 
     */
    public void setObjectsVisible()
    {
        for (int playerNum = 0; playerNum < 2; playerNum++)
        {
            for (Piece currentPiece : pieces[playerNum])
            {
                currentPiece.setInfoStatus(true);
                currentPiece.getImage().setTransparency(255);
            }// end for
        }// end for
        for (Space currentSpace : spaces)
        {
            currentSpace.getImage().setTransparency(255);
        }// end for
        die.getImage().setTransparency(255);
    } // end method setObjectsVisible
    /**
     * Shows text for the info screen.
     */
    public void showInfoText()
    {
        showText(null, 165, 295);
        showText(null, 165, 345);
        showText(null, WORLD_WIDTH / 2, TEXT_Y_POS);
        showText(null, WORLD_WIDTH/2, TEXT_Y_POS - 25);
        showText(null, WORLD_WIDTH/2, TEXT_Y_POS - 5);
        showText(null, WORLD_WIDTH/2, TEXT_Y_POS + 15);
        showText(null, WORLD_WIDTH/2, TEXT_Y_POS + 35);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 50);
        
        showText("Change gamemode:", WORLD_WIDTH/2, WORLD_HEIGHT - 95);
        showText("Press `b` for player vs player.", WORLD_WIDTH/2, WORLD_HEIGHT - 75);
        showText("Press `n` for player vs cpu (default).", WORLD_WIDTH/2, WORLD_HEIGHT - 55);
        showText("Press `m` for cpu vs cpu.", WORLD_WIDTH/2, WORLD_HEIGHT - 35);
        showText("*** Press `space` to exit the info screen. ***", WORLD_WIDTH/2, WORLD_HEIGHT - 10);
        
        showText("Armies and kings have fought throughout ", WORLD_WIDTH/2, 50);
        showText("history for reasons like political control,", WORLD_WIDTH/2, 75);
        showText("territory, social status, and ultimately power.", WORLD_WIDTH/2, 100);
        
        showText("This game includes a medieval royal theme", WORLD_WIDTH/2, 140);
        showText("and the basis of the game is that there", WORLD_WIDTH/2, 165);
        showText("are two kings fighting each other to", WORLD_WIDTH/2, 190);
        showText("accomplish a task before the other.", WORLD_WIDTH/2, 215);
        
        showText("I encourage you to do your own", WORLD_WIDTH/2, 255);
        showText("research about famous medieval battles.", WORLD_WIDTH/2, 280); 
        showText("There were monarchies or systems of", WORLD_WIDTH/2, 305);
        showText("royalty around the world, so learn", WORLD_WIDTH/2, 330);
        showText("more about your location!", WORLD_WIDTH/2, 355);
    }// end method showInfoText
    /**
     * Removes text for the info screen.
     */
    public void removeInfoText()
    {
        // all text on the screen is overwritten with null to remove it
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 95);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 75);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 55);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 35);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 10);
        
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 95);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 75);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 55);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 35);
        showText(null, WORLD_WIDTH/2, WORLD_HEIGHT - 10);
        
        showText(null, WORLD_WIDTH/2, 50);
        showText(null, WORLD_WIDTH/2, 75);
        showText(null, WORLD_WIDTH/2, 100);
        
        showText(null, WORLD_WIDTH/2, 140);
        showText(null, WORLD_WIDTH/2, 165);
        showText(null, WORLD_WIDTH/2, 190);
        showText(null, WORLD_WIDTH/2, 215);
        
        showText(null, WORLD_WIDTH/2, 255);
        showText(null, WORLD_WIDTH/2, 280); 
        showText(null, WORLD_WIDTH/2, 305);
        showText(null, WORLD_WIDTH/2, 330);
        showText(null, WORLD_WIDTH/2, 355);
    }// end method removeInfoText
    /**
     * Checks for input from the user for input change and makes changes accordingly. 
     */
    public void checkGamemode()
    {
        // Check for keypresses that represent the different game modes
        // b is player vs. player
        // n is player vs. cpu
        // m is cpu vs. cpu
        if (Greenfoot.isKeyDown("b"))
        {
            humanPlayerIndex[0] = true;
            humanPlayerIndex[1] = true;
        }// end if
        if (Greenfoot.isKeyDown("n"))
        {
            humanPlayerIndex[0] = true;
            humanPlayerIndex[1] = false;
        }// end if
        if (Greenfoot.isKeyDown("m"))
        {
            humanPlayerIndex[0] = false;
            humanPlayerIndex[1] = false;
        }// end if
    }// end method checkGamemode
}// end class Board